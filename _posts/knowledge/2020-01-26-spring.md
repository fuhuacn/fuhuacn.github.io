---
layout: post
title: Spring 面试问题
categories: Knowledge
description: Spring 面试问题
keywords: Spring,IOC,面试
---

[参考来源](https://github.com/xbox1994/Java-Interview/blob/master/MD/Web框架-Spring.md)

目录

* TOC
{:toc}

# 什么是 Spring

Spring 是个包含一系列功能的合集，如快速开发的 Spring Boot（相当于脚手架，快速搭建），支持微服务的 Spring Cloud（用 Spring Boot 的方式完成了很多为服务所应具有功能的封装），支持认证与鉴权的 Spring Security，Web 框架 Spring MVC。IOC 与 AOP 依然是核心。

# Spring MVC

## [SpringMVC、Tomcat 怎样完成一次Http请求的？](https://blog.csdn.net/achenyuan/article/details/77246395)

### Tomcat 如何调用 servlet

![Tomcat+servlet](/images/posts/knowledge/spring/tomcatServlet.jpeg)

1. Web客户向 Servlet 容器（Tomcat）发出 Http 请求
2. Servlet 容器分析客户的请求信息
3. Servlet 容器创建一个 HttpRequest 对象，将客户请求的信息封装到这个对象中
4. Servlet 容器创建一个 HttpResponse 对象
5. **Servlet 容器调用 HttpServlet 对象的 service 方法，把 HttpRequest 对象与 HttpResponse 对象作为参数传给  HttpServlet 对象**
6. HttpServlet 调用 HttpRequest 对象的有关方法，获取 Http 请求信息
7. HttpServlet 调用 HttpResponse 对象的有关方法，生成响应数据
8. Servlet 容器把 HttpServlet 的响应结果传给 Web 客户

### Tomcat 和 servlet 的映射关系如何定

**web.xml 的作用是配置 Http 和 Servlet 之间的映射关系、filter、context 参数等。**这样通过这份**约定**的配置文件，Tomcat 可以把 Http 请求映射到不同的 Servlet 实例上。所以，在 Servlet 时代的 web.xml 中，会有很多的项配置。

### SpringMVC 的转变

我们上面说过，SpringMVC 也是 Servlet 的实现，**只不过 SpringMVC 增加了一个 DispatcherServlet**（就是后面说的前端控制器），**所有的 http 请求都是映射到这个 Servlet 上**，请求进入到这个 Servlet 中之后，就算进入到了框架之中了，由这个 Servlet 来统一的分配 http 请求到各个 Controller（通过 HandlerMapping）

## 组件说明

1. DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个**流程控制的中心**，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性，系统扩展性提高，由框架实现。
2. HandlerMapping：处理器映射器。HandlerMapping 负责根据用户请求的 url 找到 Handler 即处理器，springmvc 提供了**不同的映射器实现不同的映射方式，根据一定的规则去查找**,例如：**xml 配置方式，实现接口方式，注解方式**等，由框架实现。
3. HandlAdapter：处理器适配器。通过 HandlerAdapter 对处理器进行执行，**这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行**，由框架实现。
4. Handler：处理器，后端控制器。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler **对具体的用户请求进行处理**。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler。
5. ModelAndView 是 springmvc 的封装对象，将 model 和 view 封装在一起。
6. ViewResolver：视图解析器。ViewResolver 负责**将处理结果生成 View 视图**，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。
7. View：是 springmvc 的封装对象，是一个接口， springmvc 框架提供了很多的 View 视图类型，包括：jspview、pdfview、jstlView、freemarkerView、pdfView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。

## 流程

![SpringMVC流程](/images/posts/knowledge/spring/springmvc流程.png)

SpringMVC 执行流程:

1. 用户发送请求至前端控制器 DispatcherServlet
2. DispatcherServlet 收到请求调用处理器映射器HandlerMapping。
3. 处理器映射器根据请求 url 找到具体的处理器（根据 xml、注解等），生成处理器执行链 HandlerExecutionChain（**包括处理器对象和处理器拦截器的全部处理的 handler（controller，也叫页面控制器）和拦截器**）一并返回给 DispatcherServlet。
4. DispatcherServlet 根据处理器 Handler 获取处理器适配器 HandlerAdapter 执行 HandlerAdapter 处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
5. 执行处理器 Handler。
6. Handler 执行完成返回 ModelAndView
7. HandlerAdapter 将 Handler 执行结果 ModelAndView 返回到 DispatcherServlet
8. DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器
9. ViewReslover 解析后返回具体 View
10. DispatcherServlet 对 View 进行渲染视图（即将模型数据 model 填充至视图中）。
11. DispatcherServlet 响应用户。

*上面 11 步比较复杂，简化一下流程*

DispatcherServlet 收到请求 -> HandlerMapping 查找对应 handler（controller）-> DispatcherServlet 找到 Handler 处理 -> handler 返回 ModelAndView 给 DispatcherServlet -> DispatcherServlet 找 View Resolver 解析视图 -> 返回给用户。

*收到请求 -> 找 Controller 处理 -> 获得 ModelAndView -> 解析 ModelAndView -> 返回*

## 执行流程对应的代码

*所有的序号跟代码中的注释所对应。*

1. 请求到达前端控制器的第一站，先做些准备工作。该代码在 DispatcherServlet 中，servlet 会先调用 service 方法， service 方法中调用 processRequest，在 processRequest 方法中会执行 doService 做准备工作。

    ``` java
    /**
    * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}
    * for the actual dispatching.
    */
    @Override
    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
    if (logger.isDebugEnabled()) {
        String requestUri = urlPathHelper.getRequestUri(request);
        logger.debug("DispatcherServlet with name '" + getServletName() + "' processing " + request.getMethod() +
                " request for [" + requestUri + "]");
    }

        //保护现场，存储所有的请求参数
    // Keep a snapshot of the request attributes in case of an include,
    // to be able to restore the original attributes after the include.
    Map<String, Object> attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) {
        logger.debug("Taking snapshot of request attributes before include");
        attributesSnapshot = new HashMap<String, Object>();
        Enumeration<?> attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith("org.springframework.web.servlet")) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

        //将框架相关信息存储至request，方便后面的处理器和视图用到
    // Make framework objects available to handlers and view objects.
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
    if (inputFlashMap != null) {
        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
    }
    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

        //请求分发
    try {
        doDispatch(request, response);
    }
    finally {
        // Restore the original attribute snapshot, in case of an include.
        if (attributesSnapshot != null) {
            restoreAttributesAfterInclude(request, attributesSnapshot);
        }
    }
    }
    ```

2. 处理请求。通过 url 查找 HandlerMap 中最相近的 key（url），然后由 key 获取 HandlerMapping 对象。通过处理器映射器获取处理器。通过查询处理器适配器获得 Controller 处理器。

    ``` java
    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        int interceptorIndex = -1;

        try {
            ModelAndView mv; // controller 返回的结果
            boolean errorView = false;

            try {
                processedRequest = checkMultipart(request);

                // Determine handler for the current request
                //步骤3.1~3.4用于获取包含处理器Handler和拦截器AdapterIntercepters的处理器执行链HandlerExecutionChain
                mappedHandler = getHandler(processedRequest, false);
                if (mappedHandler == null || mappedHandler.getHandler() == null) {
                    noHandlerFound(processedRequest, response);
                    return;
                }

                // Determine handler adapter for the current request.
                //步骤4.1~4.2,根据HandlerExecutionChain中的处理器Handler获取处理器适配器
                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

                    // Process last-modified header, if supported by the handler.
                String method = request.getMethod();
                boolean isGet = "GET".equals(method);
                if (isGet || "HEAD".equals(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if (logger.isDebugEnabled()) {
                    String requestUri = urlPathHelper.getRequestUri(request);
                    logger.debug("Last-Modified value for [" + requestUri + "] is: " + lastModified);
                    }
                    if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                    }
                }

                // Apply preHandle methods of registered interceptors.
                HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();
                if (interceptors != null) {
                    for (int i = 0; i < interceptors.length; i++) {
                    HandlerInterceptor interceptor = interceptors[i];
                    if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {
                        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
                        return;
                    }
                    interceptorIndex = i;
                    }
                }

                // Actually invoke the handler.
                //5.1~5.3通过处理器适配器HandlerApapter来调用处理器完成对请求的处理
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

                // Do we need view name translation?
                if (mv != null && !mv.hasView()) {
                    mv.setViewName(getDefaultViewName(request));
                }

                // Apply postHandle methods of registered interceptors.
                if (interceptors != null) {
                    for (int i = interceptors.length - 1; i >= 0; i--) {
                    HandlerInterceptor interceptor = interceptors[i];
                    interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);
                    }
                }
            }
            catch (ModelAndViewDefiningException ex) {
                logger.debug("ModelAndViewDefiningException encountered", ex);
                mv = ex.getModelAndView();
            }
            catch (Exception ex) {
                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
                mv = processHandlerException(processedRequest, response, handler, ex);
                errorView = (mv != null);
            }

            // Did the handler return a view to render?
            if (mv != null && !mv.wasCleared()) {
                render(mv, processedRequest, response);
                if (errorView) {
                    WebUtils.clearErrorRequestAttributes(request);
                }
            }
            else {
                if (logger.isDebugEnabled()) {
                    logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() +
                        "': assuming HandlerAdapter completed request handling");
                }
            }

            // Trigger after-completion for successful outcome.
            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
        }

        catch (Exception ex) {
            // Trigger after-completion for thrown exception.
            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);
            throw ex;
        }
        catch (Error err) {
            ServletException ex = new NestedServletException("Handler processing failed", err);
            // Trigger after-completion for thrown exception.
            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);
            throw ex;
        }

        finally {
            // Clean up any resources used by a multipart request.
            if (processedRequest != request) {
                cleanupMultipart(processedRequest);
            }
        }
    }
    ```

3. 1 getHandler(HttpServletRequest request)，经由 HandlerMapping 对象获取 HandlerExecutionChain（处理器和拦截器）

    ``` java
    /**
    * Return the HandlerExecutionChain for this request.
    * <p>Tries all handler mappings in order.
    * @param request current HTTP request
    * @return the HandlerExecutionChain, or <code>null</code> if no handler could be found
    */
    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        for (HandlerMapping hm : this.handlerMappings) {
            if (logger.isTraceEnabled()) {
                logger.trace(
                    "Testing handler map [" + hm + "] in DispatcherServlet with name '" + getServletName() + "'");
            }
            HandlerExecutionChain handler = hm.getHandler(request);
            if (handler != null) {
                return handler;
            }
        }
        return null;
    }
    ```

3. 2.1 getHandler(HttpServletRequest request)，经由 request 获取处理器，获取处理器 Handler 后，再获取拦截器，最后组成 HandlerExecutionChain

    ``` java
    /**
    * Look up a handler for the given request, falling back to the default
    * handler if no specific one is found.
    * @param request current HTTP request
    * @return the corresponding handler instance, or the default handler
    * @see #getHandlerInternal
    */
    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        Object handler = getHandlerInternal(request);
        if (handler == null) {
            handler = getDefaultHandler();
        }
        if (handler == null) {
            return null;
        }
        // Bean name or resolved handler?
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        return getHandlerExecutionChain(handler, request);
    }
    ```

3. 2.2 根据查找到的处理器 Handler 和 request 获取包含 Handler 和 AdaptedInterceptors 的 HandlerExecutionChain

    ``` java
    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
        HandlerExecutionChain chain = 
            (handler instanceof HandlerExecutionChain) ?
                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler);

        chain.addInterceptors(getAdaptedInterceptors());

        String lookupPath = urlPathHelper.getLookupPathForRequest(request);
        for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
            if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
                chain.addInterceptor(mappedInterceptor.getInterceptor());
            }
        }

        return chain;
        }
        /**
        * Return the adapted interceptors as HandlerInterceptor array.
        * @return the array of HandlerInterceptors, or <code>null</code> if none
        */
        protected final HandlerInterceptor[] getAdaptedInterceptors() {
        int count = adaptedInterceptors.size();
        return (count > 0) ? adaptedInterceptors.toArray(new HandlerInterceptor[count]) : null;
    }
    ```

3. 4 lookupHandler(lookupPath, request) 根据给定 url path 和 request 获取 Handler

    ``` java
    protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
        // Direct match?
        Object handler = this.handlerMap.get(urlPath);
        if (handler != null) {
            // Bean name or resolved handler?
            if (handler instanceof String) {
                String handlerName = (String) handler;
                handler = getApplicationContext().getBean(handlerName);
            }
            validateHandler(handler, request);
            return buildPathExposingHandler(handler, urlPath, urlPath, null);
        }
        // Pattern match?
        List<String> matchingPatterns = new ArrayList<String>();
        for (String registeredPattern : this.handlerMap.keySet()) {
            if (getPathMatcher().match(registeredPattern, urlPath)) {
                matchingPatterns.add(registeredPattern);
            }
        }
        String bestPatternMatch = null;
        Comparator<String> patternComparator = getPathMatcher().getPatternComparator(urlPath);
        if (!matchingPatterns.isEmpty()) {
            Collections.sort(matchingPatterns, patternComparator);
            if (logger.isDebugEnabled()) {
                logger.debug("Matching patterns for request [" + urlPath + "] are " + matchingPatterns);
            }
            bestPatternMatch = matchingPatterns.get(0);
        }
        if (bestPatternMatch != null) {
            handler = this.handlerMap.get(bestPatternMatch);
            // Bean name or resolved handler?
            if (handler instanceof String) {
                String handlerName = (String) handler;
                handler = getApplicationContext().getBean(handlerName);
            }
            validateHandler(handler, request);
            String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);

            // There might be multiple 'best patterns', let's make sure we have the correct URI template variables
            // for all of them
            Map<String, String> uriTemplateVariables = new LinkedHashMap<String, String>();
            for (String matchingPattern : matchingPatterns) {
                if (patternComparator.compare(bestPatternMatch, matchingPattern) == 0) {
                    uriTemplateVariables
                        .putAll(getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath));
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug("URI Template variables for request [" + urlPath + "] are " + uriTemplateVariables);
            }
            return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);
        }
        // No handler found...
        return null;
    }
    ```

4. 1 HandlerAdapter getHandlerAdapter(Object handler)，根据 Handler 获取 HandlerAdapter 适配器

    ``` java
    /**
    * Return the HandlerAdapter for this handler object.
    * @param handler the handler object to find an adapter for
    * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.
    */
    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
        for (HandlerAdapter ha : this.handlerAdapters) {
            if (logger.isTraceEnabled()) {
                logger.trace("Testing handler adapter [" + ha + "]");
            }
            if (ha.supports(handler)) {
                return ha;
            }
        }
        throw new ServletException("No adapter for handler [" + handler +
                "]: Does your handler implement a supported interface like Controller?");
        }
    ```

4. 2 supports(Object handler) 检测是否是 Controller

    ``` java
    public boolean supports(Object handler) {
        return (handler instanceof Controller);
    }
    ```

5. 1 使用处理器完成对请求的处理

    ``` java
    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {

        ((Servlet) handler).service(request, response);
        return null;
        }
    public void service(ServletRequest req, ServletResponse res)
        throws ServletException, IOException
    {
        HttpServletRequest  request;
        HttpServletResponse response;

        if (!(req instanceof HttpServletRequest &&
                res instanceof HttpServletResponse)) {
            throw new ServletException("non-HTTP request or response");
        }

        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;

        service(request, response);
    }
    protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
    {
        String method = req.getMethod();

        if (method.equals(METHOD_GET)) {
            long lastModified = getLastModified(req);
            if (lastModified == -1) {
                // servlet doesn't support if-modified-since, no reason
                // to go through further expensive logic
                doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
                if (ifModifiedSince < lastModified) {
                    // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
                    maybeSetLastModified(resp, lastModified);
                    doGet(req, resp);
                } else {
                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                }
            }

        } else if (method.equals(METHOD_HEAD)) {
            long lastModified = getLastModified(req);
            maybeSetLastModified(resp, lastModified);
            doHead(req, resp);

        } else if (method.equals(METHOD_POST)) {
            doPost(req, resp);

        } else if (method.equals(METHOD_PUT)) {
            doPut(req, resp);

        } else if (method.equals(METHOD_DELETE)) {
            doDelete(req, resp);

        } else if (method.equals(METHOD_OPTIONS)) {
            doOptions(req,resp);

        } else if (method.equals(METHOD_TRACE)) {
            doTrace(req,resp);

        } else {
            //
            // Note that this means NO servlet supports whatever
            // method was requested, anywhere on this server.
            //

            String errMsg = lStrings.getString("http.method_not_implemented");
            Object[] errArgs = new Object[1];
            errArgs[0] = method;
            errMsg = MessageFormat.format(errMsg, errArgs);

            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
        }
    }
    ```

剩下的原文没了，但大概逻辑清晰了，有时间再研究