---
layout: post
title: 计算机操作系统
categories: Knowledge
description: 计算机操作系统
keywords: 操作系统
---
[参考来源](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统%20-%20目录.md)

# 一、概述

## 基本特征

### 1.并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

### 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 4. 异步

同步，就是实时处理，异步，就是分时处理（如收发短信）。

对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 操作系统的基本功能

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 系统调用

操作系统本质上是一个系统程序，即为别的程序提供服务的程序。操作系统是以系统调用（system call）的方式提供服务的。

系统调用就是操作系统提供的应用程序接口（Application Programming Interface，API），用户程序即可通过调用这些 API 获得操作系统的服务；

例如，如果用户程序需要进行读磁盘内容的操作，在 C 程序代码中可使用如下的语句：

``` c
result = read(fd, buffer, nbytes);
```

该 read 函数是 C 语言提供的库函数，而这个库函数本身则是调用的操作系统的 read 系统调用。这里有两个 read：

+ 一个是 C 语言提供的 read 库函数；
+ 另一个是 read 系统调用，由操作系统提供。

编译器在看到上述语句后，将 read 库函数扩展为 read 系统调用。

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

## 大内核和微内核

+ 大内核

  大内核是将操作系统功能作为一个紧密结合的整体放到内核。

  由于各模块共享信息，因此有很高的性能。

+ 微内核

  由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

  在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

  因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

  ![微内核](/images/posts/knowledge/operationSystem/微内核.jpeg)

## 中断分类

### 中断

Linux 内核需要对连接到计算机上的所有硬件设备进行管理，毫无疑问这是它的份内事。如果要管理这些设备，首先得和它们互相通信才行，一般有两种方案可实现这种功能：

+ 轮询（polling） 让内核定期对设备的状态进行查询，然后做出相应的处理；

+ 中断（interrupt） 让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）。

第一种方案会让内核做不少的无用功，因为轮询总会周期性的重复执行，大量地耗用 CPU 时间，因此效率及其低下，所以一般都是采用第二种方案 。

### [中断、异常和陷入的对比](https://www.cnblogs.com/zhangyunhao/p/4409410.html)

中断/异常/陷入机制是操作系统由用户态转为内核态的唯一途径，是操作系统的驱动力。

中断、异常机制有以下特征：

+ 随机发生
+ 自动处理（硬件完成）
+ 可恢复

中断、异常的区别：

+ 中断属外部事件，是正在运行的程序所不期望的
+ 异常由正在执行的指令引发

在中断、异常过程中，软件和硬件分别担任什么角色：

+ 硬件--中断/异常响应
+ 软件--中断/异常处理程序
　　
中断/异常的引入目的：

+ 中断的引入是为了CPU与设备之间的并行操作
+ 异常的引入是为了表示CPU执行指令时本身出现的问题
　　
举例：一个故事：小明在看书，突然来了个电话，接完电话继续看书，这是中断；小明在看书，感觉口渴了，喝了水接着看书，这是异常。

| |类别|原因|同步/异步|返回行为|
|:---|:---:|:---:|:---:|:---:|
|中断|中断|来自I/O设备或其他硬件部件|异步|总是返回到下一条指令|
|异常|陷入|有意识安排的|同步|返回到下一条指令|
|异常|故障|可恢复的错误|同步|返回到当前指令|
|异常|终止|不可恢复的错误|同步|不会返回|

# 2. 进程管理

## 进程与线程

### 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

### 线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

### 进程与线程的区别

+ 拥有资源

  进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

+ 调度

  线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

+ 系统开销

  由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

+ 通信方面

  线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程状态的切换

![进程状态的切换](/images/posts/knowledge/operationSystem/进程切换.png)

+ 新建状态（created）：进程刚刚被创建的状态。
+ 就绪状态（ready）：备运行条件，等待系统分配处理器以便运行。
+ 运行状态（running）：占有处理器正在运行。
+ 阻塞状态（waiting）：不具备运行条件，正在等待某个事件的完成。
+ 终止状态（terminated）：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止态。进入终止态的进程以后不再执行，但依然临时保留在操作系统中等待善后。

引起进程状态转换的具体原因如下：

+ 运行态 -> 阻塞态：等待使用资源；如等待外设传输；等待人工干预。
+ 阻塞态 -> 就绪态：资源得到满足；如外设传输结束；人工干预完成。
+ 运行态 -> 就绪态：运行时间片到；出现有更高优先权进程。
+ 就绪态 -> 运行态：CPU 空闲时选择一个就绪进程。
+ NULL -> 新建态：执行一个程序，创建一个子进程。
+ 新建态 -> 就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。
+ 运行态 -> 终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。
+ 终止态 -> NULL：完成善后操作。

注意：

+ 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
+ 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 0. 操作系统分类

+ 批处理阶段

  早期的一种大型机用操作系统。可对用户作业成批处理，期间勿需用户干预，分为单道批处理系统（系统对作业的处理是成批进行的，但内存中始终保持一道作业。）和多道批处理系统（多道程序设计技术允许多个程序同时进入内存并运行）。

+ 分时操作系统

  利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。

+ 实时操作系统

  能够在指定或者确定的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统,实时意思就是对响应时间有严格要求,要以足够快的速度进行处理。分为硬实时和软实时两种。

### 1. 批处理系统调度算法

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

+ 先来先服务 first-come first-serverd（FCFS）

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

+ 短作业优先 shortest job first（SJF）

  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

+ 最短剩余时间优先 shortest remaining time next（SRTN）

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 2. 交互式系统（分时操作系统）

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

+ 时间片轮转

  将所有就绪进程按 FCFS（先来先服务）的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

  时间片轮转算法的效率和时间片的大小有很大关系：
  + 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
  + 而如果时间片过长，那么实时性就不能得到保证。

+ 优先级调度

  为每个进程分配一个优先级，按优先级进行调度。

  为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

+ 多级反馈队列

  + UNIX 的一个分支 BSD5.3 版所采用的调度算法
  + 一个综合调度算法（折中权衡）
  + 设置多个就绪队列，第一级队列优先级最高
  + 给不同就绪队列的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大。
  + 当第一级队列为空时，就在第二级队列调度，以此类推
  + 各级队列按照时间片轮转方式进行调度
  + 当一个新创建进程就绪后，进入第一级队列
  + 进程用完时间片而放弃cpu，进入下一级就绪队列
  + 由于阻塞而放弃cpu的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列

  以上所说都是属于非抢占式的，如果允许抢占，则当有一个优先级更高的进程就绪时，可以抢占cpu，被抢占的进程回到原来一级就绪队列的末尾。

  ![多级反馈队列](/images/posts/knowledge/operationSystem/多级反馈队列.png)

### 3. 实时系统

  实时系统要求一个请求在一个确定时间内得到响应。

  分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。