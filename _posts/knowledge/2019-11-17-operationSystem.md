---
layout: post
title: 计算机操作系统
categories: Knowledge
description: 计算机操作系统
keywords: 操作系统
---
[参考来源](https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机操作系统%20-%20目录.md)

# 一、概述

## 基本特征

### 1.并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

### 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 4. 异步

同步，就是实时处理，异步，就是分时处理（如收发短信）。

对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 操作系统的基本功能

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 系统调用

操作系统本质上是一个系统程序，即为别的程序提供服务的程序。操作系统是以系统调用（system call）的方式提供服务的。

系统调用就是操作系统提供的应用程序接口（Application Programming Interface，API），用户程序即可通过调用这些 API 获得操作系统的服务；

例如，如果用户程序需要进行读磁盘内容的操作，在 C 程序代码中可使用如下的语句：

``` c
result = read(fd, buffer, nbytes);
```

该 read 函数是 C 语言提供的库函数，而这个库函数本身则是调用的操作系统的 read 系统调用。这里有两个 read：

+ 一个是 C 语言提供的 read 库函数；
+ 另一个是 read 系统调用，由操作系统提供。

编译器在看到上述语句后，将 read 库函数扩展为 read 系统调用。

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

## 大内核和微内核

+ 大内核

  大内核是将操作系统功能作为一个紧密结合的整体放到内核。

  由于各模块共享信息，因此有很高的性能。

+ 微内核

  由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

  在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

  因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

  ![微内核](/images/posts/knowledge/operationSystem/微内核.jpeg)

## 中断分类

### 中断

Linux 内核需要对连接到计算机上的所有硬件设备进行管理，毫无疑问这是它的份内事。如果要管理这些设备，首先得和它们互相通信才行，一般有两种方案可实现这种功能：

+ 轮询（polling） 让内核定期对设备的状态进行查询，然后做出相应的处理；

+ 中断（interrupt） 让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）。

第一种方案会让内核做不少的无用功，因为轮询总会周期性的重复执行，大量地耗用 CPU 时间，因此效率及其低下，所以一般都是采用第二种方案 。

### [中断、异常和陷入的对比](https://www.cnblogs.com/zhangyunhao/p/4409410.html)

中断/异常/陷入机制是操作系统由用户态转为内核态的唯一途径，是操作系统的驱动力。

中断、异常机制有以下特征：

+ 随机发生
+ 自动处理（硬件完成）
+ 可恢复

中断、异常的区别：

+ 中断属外部事件，是正在运行的程序所不期望的
+ 异常由正在执行的指令引发

在中断、异常过程中，软件和硬件分别担任什么角色：

+ 硬件--中断/异常响应
+ 软件--中断/异常处理程序
　　
中断/异常的引入目的：

+ 中断的引入是为了CPU与设备之间的并行操作
+ 异常的引入是为了表示CPU执行指令时本身出现的问题
　　
举例：一个故事：小明在看书，突然来了个电话，接完电话继续看书，这是中断；小明在看书，感觉口渴了，喝了水接着看书，这是异常。

| |类别|原因|同步/异步|返回行为|
|:---|:---:|:---:|:---:|:---:|
|中断|中断|来自I/O设备或其他硬件部件|异步|总是返回到下一条指令|
|异常|陷入|有意识安排的|同步|返回到下一条指令|
|异常|故障|可恢复的错误|同步|返回到当前指令|
|异常|终止|不可恢复的错误|同步|不会返回|

# 2. 进程管理

## 进程与线程

### 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

### 线程

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

### 进程与线程的区别

+ 拥有资源

  进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

+ 调度

  线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

+ 系统开销

  由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

+ 通信方面

  线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程状态的切换

![进程状态的切换](/images/posts/knowledge/operationSystem/进程切换.png)

+ 新建状态（created）：进程刚刚被创建的状态。
+ 就绪状态（ready）：备运行条件，等待系统分配处理器以便运行。
+ 运行状态（running）：占有处理器正在运行。
+ 阻塞状态（waiting）：不具备运行条件，正在等待某个事件的完成。
+ 终止状态（terminated）：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止态。进入终止态的进程以后不再执行，但依然临时保留在操作系统中等待善后。

引起进程状态转换的具体原因如下：

+ 运行态 -> 阻塞态：等待使用资源；如等待外设传输；等待人工干预。
+ 阻塞态 -> 就绪态：资源得到满足；如外设传输结束；人工干预完成。
+ 运行态 -> 就绪态：运行时间片到；出现有更高优先权进程。
+ 就绪态 -> 运行态：CPU 空闲时选择一个就绪进程。
+ NULL -> 新建态：执行一个程序，创建一个子进程。
+ 新建态 -> 就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。
+ 运行态 -> 终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。
+ 终止态 -> NULL：完成善后操作。

注意：

+ 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
+ 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 0. 操作系统分类

+ 批处理阶段

  早期的一种大型机用操作系统。可对用户作业成批处理，期间勿需用户干预，分为单道批处理系统（系统对作业的处理是成批进行的，但内存中始终保持一道作业。）和多道批处理系统（多道程序设计技术允许多个程序同时进入内存并运行）。

+ 分时操作系统

  利用分时技术的一种联机的多用户交互式操作系统，每个用户可以通过自己的终端向系统发出各种操作控制命令，完成作业的运行。分时是指把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。

+ 实时操作系统

  能够在指定或者确定的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统,实时意思就是对响应时间有严格要求,要以足够快的速度进行处理。分为硬实时和软实时两种。

### 1. 批处理系统调度算法

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

+ 先来先服务 first-come first-serverd（FCFS）

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

+ 短作业优先 shortest job first（SJF）

  非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

+ 最短剩余时间优先 shortest remaining time next（SRTN）

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 2. 交互式系统（分时操作系统）

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

+ 时间片轮转

  将所有就绪进程按 FCFS（先来先服务）的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

  时间片轮转算法的效率和时间片的大小有很大关系：
  + 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
  + 而如果时间片过长，那么实时性就不能得到保证。

+ 优先级调度

  为每个进程分配一个优先级，按优先级进行调度。

  为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

+ 多级反馈队列

  + UNIX 的一个分支 BSD5.3 版所采用的调度算法
  + 一个综合调度算法（折中权衡）
  + 设置多个就绪队列，第一级队列优先级最高
  + 给不同就绪队列的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大。
  + 当第一级队列为空时，就在第二级队列调度，以此类推
  + 各级队列按照时间片轮转方式进行调度
  + 当一个新创建进程就绪后，进入第一级队列
  + 进程用完时间片而放弃cpu，进入下一级就绪队列
  + 由于阻塞而放弃cpu的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列

  以上所说都是属于非抢占式的，如果允许抢占，则当有一个优先级更高的进程就绪时，可以抢占cpu，被抢占的进程回到原来一级就绪队列的末尾。

  ![多级反馈队列](/images/posts/knowledge/operationSystem/多级反馈队列.png)

### 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 进程同步

### 1. 临界资源

在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等（如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题）。

对于临界资源的访问，必须是互诉进行。也就是**当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。**而进程内访问临界资源的代码被成为临界区。

对于临界区的访问过程分为四个部分：

1. 进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞。

2. 临界区:在临界区做操作。

3. 退出区:清除临界区被占用的标志。

4. 剩余区：进程与临界区不相关部分的代码。

### 2. 同步与互斥

+ 同步：**多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。**
  比如说进程 B 需要从缓冲区读取进程 A 产生的信息，当缓冲区为空时，进程 B 因为读取不到信息而被阻塞。而当进程 A 产生信息放入缓冲区时，进程 B 才会被唤醒。
+ 互斥：**多个进程在同一时刻只有一个进程能进入临界区。**
  比如进程B需要访问打印机，但此时进程A占有了打印机，进程B会被阻塞，直到进程A释放了打印机资源,进程B才可以继续执行。

### 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作（P 和 V 操作分别来自荷兰语 Passeren 和 Vrijgeven，分别表示占有和释放）。

+ down（P）：表示有一个进程将占用或等待资源，如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
+ up（V）：表示占用或等待资源的进程减少了1个。对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

**使用信号量实现生产者-消费者问题：**

本作业要求设计在同一个进程地址空间内执行的两个线程。生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。当生产者线程生产物品时，如果没有空缓冲区可用，那么生产者线程必须等待消费者线程释放出一个空缓冲区。当消费者线程消费物品时，如果没有满的缓冲区，那么消费者线程将被阻塞，直到新的物品被生产出来。

这里生产者和消费者是既同步又互斥的关系，首先只有生产者生产了，消费着才能消费，这里是同步的关系。但他们对于临界区的访问又是互斥的关系。因此需要三个信号量 empty 和 full 用于同步缓冲区（对缓冲区剩余或满加减），而 mut 变量用于在访问缓冲区时是互斥的（0、1 控制消费者或生产者是否可以访问）。

``` c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

### 4. 管程（Monitor）

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

在并发编程领域，有两大核心问题：
一个是互斥，即同一时刻只允许一个线程访问共享资源；
另一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。

+ 我们先来看看管程是如何解决互斥问题的：

  管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。在下图中，管程 X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq() 都封装起来了；线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq() 保证互斥性，只允许一个线程进入管程。

+ 管程如何解决线程间的同步问题:

  + enq的时候while判断队列是否满了，如果满了，notFull.await()阻塞当前线程;
  + enq如果没满，添加对象，并且用notEmpty.single()通知deque停止阻塞；
  + deq可以顺利执行出队列的操作；
  + deq的时候while判断队列是否为空，如果为空，notEmpty.await()阻塞当前线程;
  + deq如果不为空，poll对象，并且用notFull.single()通知enq停止阻塞；
  + enq可以顺利执行队列

管程引入了 条件变量（也有可能是 Condition） 以及相关的操作：wait() 和 signal()/notify() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

下面是 BlockingQueue 的 [JAVA 代码](https://liuhao163.github.io/JAVA中的管程/)：

>关于 Condition 接口：  
Condition是个接口，基本的方法就是await()和signal()方法；  
Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 
调用Condition的await()和signal() 方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用  
Conditon中的await()对应Object的wait()；  
Condition中的signal()对应Object的notify()；  
Condition中的signalAll()对应Object的notifyAll()。  
*使用 Condition 相比于 notify 的优势是，可以对任何一个 lock 生成一个对应的 Condition，分解业务。而传统的 wait 和 notify 都是对 Object 的，一旦 notify 就全唤醒了。*

``` java
public class BlockQueue {
    ReentrantLock lock = new ReentrantLock();

    // 使用 condition 的优势就在这里，他可以对每个具体情况进行 await 和 signal
    Condition notFull = lock.newCondition();
    Condition notEmpty = lock.newCondition();

    private Queue queue = new LinkedList();
    private int queSize = 10;

    public BlockQueue(int queSize) {
        this.queSize = queSize;
    }

    public void enq(Object o) {
        lock.lock();
        try {
            //如果为慢noFull阻塞线程
            while (queue.size() == queSize) {
                notFull.await();
            }

            queue.add(o);
            //添加成功通知deq停止阻塞
            notEmpty.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public Object deque() {
        lock.lock();
        Object ret = null;
        try {
           //如果为空notEmpty阻塞线程
            while (queue.size() == 0) {
                notEmpty.await();
            }
            return queue.poll();
        } catch (InterruptedException e) {
            e.printStackTrace();
            return null;
        } finally {
            //出队列成功通知队列未满可以入队列
            notFull.signal();
            lock.unlock();
        }
    }
}
```

