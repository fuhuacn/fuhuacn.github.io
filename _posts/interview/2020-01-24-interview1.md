---
layout: post
title: 阿里 - 面经学习 1
categories: Interview
description: 阿里 - 面经学习 1
keywords: 面经
---

面试题来自：[链接](https://blog.csdn.net/zlx312/article/details/79437015)

目录

* TOC
{:toc}

# 一、网络

## 子网掩码是什么？有什么作用

使用的 IPv4 协议对 IP 地址强行定义了一些保留地址，即：“网络地址”和“广播地址”。所谓“网络地址”就是指“主机号”全为“0”的IP地址，如：125.0.0.0（A类地址）；而“广播地址”就是指“主机号”全为“255”时的IP地址，如：125.255.255.255（A类地址）。

子网掩码是用来标识两个 IP 地址是否同属于一个子网。其每一位上的数值代表不同含义：为“1”则代表该位是网络位；若为“0”则代表该位是主机位。如果两个 IP 地址分别与同一个子网掩码进行按位“与”计算后得到相同的结果，即表明这两个 IP 地址处于同一个子网中。

## TCP 三次握手，能两次握手嘛

1. 客户端发送 SYN 连接请求。
2. 服务端像客户端发送确认 ACK 报文，客户端 ESTABLISHED
3. 客户端收到报文后想服务端发出 ACK 确认，服务端 ESTABLISHED

不能两次握手。因为客户端有超时重传机制。例如当出现网络滞留时，服务端返回的 ACK 客户端迟迟没有收到，就会再次发送建立连接指令。如果只有两次握手，那当服务端返回 ACK 时，服务端自己就已经认为自己建立连接了，这时如果有重传就会建立多个连接，但客户端其实只有一个连接。使用三次握手的话，客户端收到 ACK 后在发送 ACK 给服务端才建立连接，可以保证只有一个连接。

*引申四次挥手*

1. 客户端发送完全部数据，发送给服务端 FIN 请求结束。
2. 服务端返回 ACK 表示知道要结束了，同时此时依然发送未完的数据。
3. 服务端数据发送完毕，发送 FIN 表示自己想要结束。
4. 客户端收到 FIN，返回 ACK。服务端 CLOSED，客户端等待 2 倍最大报文存活时间结束。

四次挥手原因是服务端会有未发完数据，发完后才能通知客户端可以结束。等待最后一个 ACK 才关是因为不知道客户端会不会又没收到的数据等待重传。

TIME_WAIT 是因为要确认服务端收到了最后的确认报文（比如最后服务端没有收到客户端的确认 ACK 就无法关闭了，服务端会重传），同时让本连接所有报文都消失，使得下一个连接不会再有旧连接数据。

## TCP 和 UDP 区别

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP少）；
3. UDP程序结构较简单；
4. 流模式与数据报模式 ；
5. TCP保证数据正确性，UDP可能丢包；
6. TCP保证数据顺序，UDP不保证。

# 数据库

## 事务 ACID

- 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
- 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

Atomic 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

Consistently 一致性：ACID 中唯一由开发者保证的。一致性是指系统从一个正确的状态,迁移到另一个正确的状态。也就是事务前后状态都是正确的。

Isolation 隔离：一个事务所做的修改在最终提交以前，对其它事务是不可见的。分为四个等级：读未提交、读已提交、可重复读、串行化。

Durability 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。

## 隔离特性

+ 未提交读 Read Uncommitted：可以读到别的事务没有提交的。所以会产生脏读（人家改完又回滚了，结果读到的是改完的）。
+ 已提交读 Read Committed：只能读取到已提交事物的修改，事务之内的修改是不可见的。因此也就解决了脏读，但无法解决不可重复读（一个事物查询两次某行的值中间，那一行被另一个事务修改并已提交）。
+ 可重复读 Repeatable Read：保证在同一个事务中多次读取同样数据的结果是一样的。
+ 串行 Serializable：强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。

MySQL 默认可重复读。Oracle 默认已提交读。

## 数据库脏读、幻读是什么？隔离特性有什么影响？

+ 脏读：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
+ 幻读：T1在一个事务内读取某个范围的数据，T2在这个范围内插入新的数据（已提交），T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。串行可以解决这一问题。