---
layout: post
title: LeetCode 树专题
categories: Prolems
description: LeetCode 树专题
keywords: leetcode,树
---

目录

* TOC
{:toc}

## 101. 对称二叉树 简单

* 题目描述

    给定一个二叉树，检查它是否是镜像对称的。

    例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    **Example:**

    > 略

* 解法

    一直递归判断左子树的左子树是否等于右子树的右子树，左子树的右子树是否等于右子树的左子树。

* 代码

    ``` java
    /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
    class Solution {
        public boolean isSymmetric(TreeNode root) {
            if(root==null) return true;
            return isSymmetricHelper(root.left,root.right);
        }
        public boolean isSymmetricHelper(TreeNode left, TreeNode right) {
            if(left==null&&right==null) return true;
            if(left==null||right==null) return false;
            if(left.val!=right.val) return false;
            return isSymmetricHelper(left.left,right.right) && isSymmetricHelper(left.right,right.left);
        }
    }
    ```

## 104. 二叉树的最大深度 简单

* 题目描述

    给定一个二叉树，找出其最大深度。

    二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

    **说明: **叶子节点是指没有子节点的节点。

    **Example:**

    > 略

* 解法

    递归，取左右子树的最大深度并加一。

* 代码

    ``` java
    /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
    class Solution {
        public int maxDepth(TreeNode root) {
            if(root==null) return 0;
            return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
        }
    }
    ```