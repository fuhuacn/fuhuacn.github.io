---
layout: post
title: 动态规划专题 1
categories: Prolems
description: 动态规划专题 1
keywords: leetcode,动态规划
---

目录

* TOC
{:toc}

## 53. 最大子序和 简单

* 题目描述

    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

    **Example:**

    > 输入: [-2,1,-3,4,-1,2,1,-5,4],  
    输出: 6  
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

* 解法

    连续到某个位置的最大值可能是上一位加上这个值和这个值的最大值。

* 代码

    ``` java
    class Solution {
        public int maxSubArray(int[] nums) {
            if(nums.length==0) return 0;
            int[] dp = new int[nums.length];//因为在动态规划专题，就写复杂些，用动态规划了，其实他只需要关注最新的最大值，所以用个常量保存就够了。dp[i] 表示的是连续到第 i 个位置的最大值（必须含 nums[i]）。递推公式 dp[i] = Math.max(dp[i-1]+nums[i],nums[i])
            int max = nums[0];
            dp[0] = nums[0];
            for(int i=1;i<nums.length;i++){
                dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
                max = Math.max(max,dp[i]);
            }
            return max;
        }
    }
    ```

## 300. 最长上升子序列 中等

* 题目描述

    给定一个无序的整数数组，找到其中最长上升子序列的长度。

    **Example:**

    > 输入: [10,9,2,5,3,7,101,18]  
    输出: 4   
    解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

* 解法

    用一个数组保存目前的递增序列，新的数去替换最小的一个比新的数大的数。如果他比最后一个数大，就插入数组。关键是二分法怎么去找。

* 代码

    ``` java
    class Solution {
        public int lengthOfLIS(int[] nums) {
            if(nums.length==0) return 0;
            int[] dp = new int[nums.length]; //dp是一个有可能的数组，在数组的遍历过程中，只要把最小的大于这个位置的数替换掉就好了，如果没有这个数，则补充在数组后面，因为他比所有数都大。这个数组也一定是个递增的
            dp[0] = nums[0];
            int end = 0;
            for(int num:nums){
                int index = binarySearch(dp,end,num);
                dp[index] = num;
                if(index>end) end = index;
            }
            return end+1;
        }
        public int binarySearch(int[] dp,int end, int num){ // 因为数组长度提前定下来的，所以有个 end
            if(num>dp[end]){
                return end+1;
            }
            int start = 0;
            while(start<end){
                int mid = start+(end-start)/2;
                if(dp[mid]>num){
                    end = mid; //不要写 mid-1，这是最小的比他大的，有可能就是 mid 是最小的比他大的。
                }else if(dp[mid]<num){
                    start = mid+1;
                }else{
                    return mid; //如果等于证明不用替换了
                }
            }
            return start;
        }
    }
    ```