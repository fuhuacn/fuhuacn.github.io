---
layout: post
title: LeetCode 链表专题
categories: Prolems
description: LeetCode 链表专题
keywords: leetcode,链表
---

目录

* TOC
{:toc}

## 17. 电话号码的字母组合 中等

* 题目描述

    给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

    给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

    **Example:**

    > 输入："23"  
    输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

* 解法

    dfs，把所有的对应关系放到一个 map 中。dfs 时循环这个 map 的数组。

* 代码

    ``` java
    class Solution {
        Map<Character,char[]> map = new HashMap<>();
        public List<String> letterCombinations(String digits) {
            map.put('2',new char[]{'a','b','c'});
            map.put('3',new char[]{'d','e','f'});
            map.put('4',new char[]{'g','h','i'});
            map.put('5',new char[]{'j','k','l'});
            map.put('6',new char[]{'m','n','o'});
            map.put('7',new char[]{'p','q','r','s'});
            map.put('8',new char[]{'t','u','v'});
            map.put('9',new char[]{'w','x','y','z'});
            List<String> res = new LinkedList<>();
            if(digits.equals("")) return res;
            char[] cs = digits.toCharArray();
            char[] word = new char[cs.length];
            dfs(res, word, cs, 0);
            return res;
        }
        public void dfs(List<String> res, char[] word, char[] cs, int index){
            if(index == cs.length){
                res.add(new String(word));
                return;
            }
            char[] ss = map.get(cs[index]);
            for(int i=0;i<ss.length;i++){
                word[index] = ss[i];
                dfs(res,word,cs,index+1);
            }
        }
    }
    ```

## 46. 全排列 中等

* 题目描述

    给定一个没有重复数字的序列，返回其所有可能的全排列。

    **Example:**

    > 输入: [1,2,3]  
    输出:  
    [  
    [1,2,3],  
    [1,3,2],  
    [2,1,3],  
    [2,3,1],  
    [3,1,2],  
    [3,2,1]  
    ]

* 解法

    dfs，对每两位做交换。相当于保持前 i 位不动，交换之后的每一位和 index 位。

* 代码

    ``` java
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new LinkedList<>();
            if(nums.length == 0) return res;
            dfs(res, nums, 0);
            return res;
        }
        public void dfs(List<List<Integer>> res, int[] nums, int index){
            if(index == nums.length){
                LinkedList<Integer> list = new LinkedList<>();
                for(int num:nums){
                    list.add(num);
                }
                res.add(list);
                return;
            }
            for(int i=index;i<nums.length;i++){
                swap(nums,i,index);
                dfs(res,nums,index+1);
                swap(nums,i,index);
            }
        }
        public void swap(int[] list, int a, int b){
            int temp = list[a];
            list[a] = list[b];
            list[b] = temp;
        }
    }
    ```

## 47. 全排列 II 中等

* 题目描述

    给定一个有重复数字的序列，返回其所有可能的全排列。

    **Example:**

    > 输入: [1,1,2]  
    输出:  
    [  
    [1,1,2],  
    [1,2,1],  
    [2,1,1]  
    ]

* 解法

    最简单的方法是把上面的例子 list 转换成 set。

* 代码

    ``` java
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> res = new LinkedList<>();
            if(nums.length == 0) return res;
            dfs(res, nums, 0);
            return res;
        }
        public void dfs(List<List<Integer>> res, int[] nums, int index){
            if(index == nums.length){
                LinkedList<Integer> list = new LinkedList<>();
                for(int num:nums){
                    list.add(num);
                }
                res.add(list);
                return;
            }
            for(int i=index;i<nums.length;i++){
                swap(nums,i,index);
                dfs(res,nums,index+1);
                swap(nums,i,index);
            }
        }
        public void swap(int[] list, int a, int b){
            int temp = list[a];
            list[a] = list[b];
            list[b] = temp;
        }
    }
    ```

## 78. 子集 中等

* 题目描述

    给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

    说明：解集不能包含重复的子集。

    **Example:**

    > 输入: nums = [1,2,3]  
    输出:  
    [  
    [3],  
    [1],  
    [2],  
    [1,2,3],  
    [1,3],  
    [2,3],  
    [1,2],  
    []  
    ]

* 解法

    因为是求子集，不需要交换。dfs，只不过这次不是到了数量满足才加进去，而是每有一步操作就加进去。

* 代码

    ``` java
    class Solution {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> res = new LinkedList<>();
            if(nums.length==0) return res;
            LinkedList<Integer> list = new LinkedList<>();
            res.add(new ArrayList<Integer>(list));
            dfs(res,list,nums,0);
            return res;
        }
        public void dfs(List<List<Integer>> res, LinkedList<Integer> list, int[] nums, int index){
            for(int i=index;i<nums.length;i++){
                list.add(nums[i]);
                res.add(new ArrayList<Integer>(list));
                dfs(res,list,nums,i+1);
                list.removeLast();
            }
        }
    }
    ```